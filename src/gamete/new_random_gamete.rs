use super::Gamete;
use crate::locus::Locus;

use rand::Rng;
use std::ops::RangeInclusive;

impl Gamete {
    /// Creates a new random Gamete.
    ///
    /// Each Locus in the Gamete's DNA is generated by calling `new_random_locus`
    /// with the corresponding bounds from `parameter_bounds`.
    ///
    /// # Arguments
    ///
    /// * `rng`: A mutable reference to a random number generator.
    /// * `parameter_bounds`: A slice of `RangeInclusive<f64>` specifying the value
    ///   bounds for each Locus to be created. The length of this slice determines
    ///   the number of loci in the resulting gamete.
    ///
    /// # Returns
    ///
    /// A new `Gamete` instance with randomly initialized loci.
    pub fn new_random_gamete(rng: &mut impl Rng, parameter_bounds: &[RangeInclusive<f64>]) -> Self {
        let loci: Vec<Locus> = parameter_bounds
            .iter()
            .map(|bounds| Locus::new_random_locus(rng, bounds))
            .collect();
        Gamete::new(loci)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    // LocusAdjustment related imports are not strictly needed for current tests but kept for potential future expansion.
    #[allow(unused_imports)]
    use crate::locus::locus_adjustment::{DirectionOfTravel, LocusAdjustment};

    use rand::SeedableRng;
    use rand::rngs::StdRng;
    use std::ops::RangeInclusive;

    // Helper to create a mock RNG for deterministic tests
    fn get_mock_rng() -> StdRng {
        StdRng::seed_from_u64(42)
    }

    #[test]
    fn given_empty_bounds_when_new_random_gamete_then_gamete_is_empty() {
        let mut rng = get_mock_rng();
        let parameter_bounds: [RangeInclusive<f64>; 0] = [];
        let gamete = Gamete::new_random_gamete(&mut rng, &parameter_bounds);
        assert!(gamete.is_empty());
        assert_eq!(gamete.len(), 0);
    }

    #[test]
    fn given_some_bounds_when_new_random_gamete_then_gamete_has_correct_number_of_loci() {
        let mut rng = get_mock_rng();
        let parameter_bounds = vec![0.0..=1.0, 10.0..=20.0, 100.0..=200.0];
        let gamete = Gamete::new_random_gamete(&mut rng, &parameter_bounds);
        assert_eq!(gamete.len(), 3);
    }

    #[test]
    fn given_bounds_when_new_random_gamete_then_loci_are_created_with_correct_value_bounds() {
        let mut rng = get_mock_rng();
        let parameter_bounds = vec![
            0.0..=1.0,  // For first locus
            5.0..=10.0, // For second locus
        ];
        let gamete = Gamete::new_random_gamete(&mut rng, &parameter_bounds);

        assert_eq!(gamete.len(), 2);

        let loci = gamete.loci();

        // Check bounds of the value Parameter for the first locus
        let locus0_value_param = loci[0].value();
        assert_eq!(*locus0_value_param.bounds(), parameter_bounds[0]);
        assert!(
            locus0_value_param.get() >= *parameter_bounds[0].start(),
            "Locus 0 value {} is not >= start {}",
            locus0_value_param.get(),
            *parameter_bounds[0].start()
        );
        assert!(
            locus0_value_param.get() <= *parameter_bounds[0].end(),
            "Locus 0 value {} is not <= end {}",
            locus0_value_param.get(),
            *parameter_bounds[0].end()
        );

        // Check bounds of the value Parameter for the second locus
        let locus1_value_param = loci[1].value();
        assert_eq!(*locus1_value_param.bounds(), parameter_bounds[1]);
        assert!(
            locus1_value_param.get() >= *parameter_bounds[1].start(),
            "Locus 1 value {} is not >= start {}",
            locus1_value_param.get(),
            *parameter_bounds[1].start()
        );
        assert!(
            locus1_value_param.get() <= *parameter_bounds[1].end(),
            "Locus 1 value {} is not <= end {}",
            locus1_value_param.get(),
            *parameter_bounds[1].end()
        );
    }
}
