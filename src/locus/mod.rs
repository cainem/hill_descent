// src/locus/mod.rs
pub mod locus_adjustment;
pub mod mutate; // Declare the new mutate module

use crate::parameters::parameter::Parameter;

use self::locus_adjustment::{DirectionOfTravel, LocusAdjustment};
use rand::Rng;
use std::ops::RangeInclusive;
// Rng and SystemParameters are no longer directly used in this file's non-test code.
// DirectionOfTravel is only used in tests.

#[derive(Debug, Clone, PartialEq)]
pub struct Locus {
    pub value: Parameter, // Represents LocusValue
    pub adjustment: LocusAdjustment,
    pub apply_adjustment_flag: bool,
}

impl Locus {
    /// Creates a new Locus.
    pub fn new(value: Parameter, adjustment: LocusAdjustment, apply_adjustment_flag: bool) -> Self {
        Self {
            value,
            adjustment,
            apply_adjustment_flag,
        }
    }

    /// Returns a reference to the LocusValue (Parameter).
    pub fn value(&self) -> &Parameter {
        &self.value
    }

    /// Returns a reference to the LocusAdjustment.
    pub fn adjustment(&self) -> &LocusAdjustment {
        &self.adjustment
    }

    /// Returns the ApplyAdjustmentFlag.
    pub fn apply_adjustment_flag(&self) -> bool {
        self.apply_adjustment_flag
    }

    // The 'mutate' method has been moved to src/locus/mutate.rs

    /// Creates a new Locus with random properties within the given value_bounds.
    ///
    /// - `value`: A random f64 within `value_bounds`, stored in a Parameter whose own bounds are set to `value_bounds`.
    /// - `apply_adjustment_flag`: Randomly true or false (50/50).
    /// - `adjustment`: A LocusAdjustment generated by `LocusAdjustment::new_random`.
    ///   However, if its `doubling_or_halving_flag` is true, a check is performed.
    ///   If applying this doubling/halving to the Locus's `value` would result in a value
    ///   outside `value_bounds`, then the `doubling_or_halving_flag` for this Locus's
    ///   specific adjustment instance is overridden to `false`.
    pub fn new_random(rng: &mut impl Rng, value_bounds: RangeInclusive<f64>) -> Self {
        let random_value = rng.gen_range(value_bounds.clone());
        let locus_value_param =
            Parameter::with_bounds(random_value, *value_bounds.start(), *value_bounds.end());

        let apply_adjustment_flag = rng.r#gen::<bool>();

        let mut initial_adjustment = LocusAdjustment::new_random(rng, &value_bounds);

        if initial_adjustment.doubling_or_halving_flag() {
            let current_val = locus_value_param.get();
            let hypothetical_value = match initial_adjustment.direction_of_travel() {
                DirectionOfTravel::Add => current_val * 2.0, // Doubling
                DirectionOfTravel::Subtract => current_val / 2.0, // Halving
            };

            if !value_bounds.contains(&hypothetical_value) {
                // Override: create a new adjustment with doubling_or_halving_flag set to false
                initial_adjustment = LocusAdjustment::new(
                    initial_adjustment.adjustment_value().clone(), // Keep original random adjustment value
                    initial_adjustment.direction_of_travel(),
                    false, // Force doubling_or_halving_flag to false
                );
            }
        }

        Self {
            value: locus_value_param,
            adjustment: initial_adjustment,
            apply_adjustment_flag,
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::parameters::parameter::Parameter;
    use rand::SeedableRng;
    use rand::rngs::StdRng;

    use self::locus_adjustment::{DirectionOfTravel, LocusAdjustment}; // DirectionOfTravel needed for create_test_adjustment
    use super::*; // Brings Locus struct and its methods (new, value, etc.) into scope
    // StepRng and SystemParameters are no longer needed for tests in this file.

    // Helper function to create a LocusAdjustment for tests
    fn create_test_adjustment(
        value: f64,
        direction: DirectionOfTravel,
        flag: bool,
    ) -> LocusAdjustment {
        LocusAdjustment::new(Parameter::new(value), direction, flag)
    }

    // Helper function to create a Parameter for tests
    fn create_test_parameter(value: f64) -> Parameter {
        Parameter::new(value)
    }

    // create_test_locus has been moved to src/locus/mutate.rs tests

    #[test]
    fn given_valid_params_when_new_then_locus_fields_are_set_correctly() {
        let param_val = create_test_parameter(10.5);
        let adj = create_test_adjustment(1.0, DirectionOfTravel::Add, false);
        let flag = true;

        let locus = Locus::new(param_val.clone(), adj.clone(), flag);

        assert_eq!(locus.value(), &param_val);
        assert_eq!(locus.adjustment(), &adj);
        assert_eq!(locus.apply_adjustment_flag(), flag);
    }

    #[test]
    fn given_locus_when_value_called_then_returns_correct_value() {
        let param_val = create_test_parameter(-5.0);
        let adj = create_test_adjustment(0.5, DirectionOfTravel::Subtract, true);
        let flag = false;
        let locus = Locus::new(param_val.clone(), adj.clone(), flag);

        assert_eq!(locus.value(), &param_val);
    }

    #[test]
    fn given_locus_when_adjustment_called_then_returns_correct_adjustment() {
        let param_val = create_test_parameter(20.0);
        let adj = create_test_adjustment(2.0, DirectionOfTravel::Add, false);
        let flag = true;
        let locus = Locus::new(param_val.clone(), adj.clone(), flag);

        assert_eq!(locus.adjustment(), &adj);
    }

    #[test]
    fn given_locus_when_apply_adjustment_flag_called_then_returns_correct_flag() {
        let param_val = create_test_parameter(0.0);
        let adj = create_test_adjustment(0.0, DirectionOfTravel::Subtract, false);

        let flag_true = true;
        let locus_true = Locus::new(param_val.clone(), adj.clone(), flag_true);
        assert_eq!(locus_true.apply_adjustment_flag(), flag_true);

        let flag_false = false;
        let locus_false = Locus::new(param_val.clone(), adj.clone(), flag_false);
        assert_eq!(locus_false.apply_adjustment_flag(), flag_false);
    }

    // Mutate tests ('mutate_no_mutation_returns_same', 'mutate_with_full_probs_applies_flag_flip')
    // have been moved to src/locus/mutate.rs

    #[test]
    fn given_rng_and_bounds_when_new_random_then_locus_is_valid() {
        let mut rng = StdRng::seed_from_u64(42);
        let bounds = -10.0..=10.0;

        for _ in 0..100 {
            let locus = Locus::new_random(&mut rng, bounds.clone());
            assert!(
                bounds.contains(&locus.value().get()),
                "Locus value {} out of bounds {:?}",
                locus.value().get(),
                &bounds
            );
            assert_eq!(
                locus.value().bounds(),
                &bounds,
                "Locus parameter bounds incorrect"
            );
            // Adjustment value itself should be non-negative as per LocusAdjustment::new_random
            assert!(locus.adjustment().adjustment_value().get() >= 0.0);
        }
    }

    #[test]
    fn given_new_random_locus_when_dh_flag_true_and_doubling_out_of_bounds_then_dh_flag_is_false() {
        let bounds = 50.0..=100.0;

        // We need to find a seed or sequence of calls that results in:
        // 1. locus.value.get() > 50.0 (e.g., 75.0, so doubling makes it 150.0, which is out of bounds)
        // 2. initial_adjustment.doubling_or_halving_flag() is true
        // 3. initial_adjustment.direction_of_travel() is Add (for doubling)

        for i in 0..500 {
            // Try a few times to get the desired RNG state
            let mut seeded_rng = StdRng::seed_from_u64(i);
            let locus_val_candidate = seeded_rng.gen_range(bounds.clone());

            // Simulate the generation of initial_adjustment parts to check conditions
            let dir_travel_candidate_is_add = seeded_rng.r#gen::<bool>(); // For LocusAdjustment's direction
            let dh_flag_candidate_is_true = seeded_rng.r#gen::<bool>(); // For LocusAdjustment's D/H flag
            // apply_adjustment_flag for Locus itself is also generated by rng but not relevant here
            seeded_rng.r#gen::<bool>(); // Consume the bool that would be for Locus's apply_adjustment_flag
            // The adjustment value for LocusAdjustment also consumes from RNG, skip for this check's purpose
            // seeded_rng.gen_range(0.0..=((bounds.end() - bounds.start()).abs() * 0.1).max(crate::E0));

            if locus_val_candidate > *bounds.start() + (*bounds.end() - *bounds.start()) / 2.0 && // e.g. > 75 for 50-100 range
                dh_flag_candidate_is_true && 
                dir_travel_candidate_is_add
            {
                // Re-seed for the actual Locus::new_random call to ensure same sequence
                let mut test_rng = StdRng::seed_from_u64(i);
                let locus = Locus::new_random(&mut test_rng, bounds.clone());

                // Verify the conditions we were aiming for did occur for the *initial* adjustment idea
                // This is tricky because the actual initial_adjustment is internal to new_random
                // But we can check the *final* outcome
                if locus.value.get() * 2.0 > *bounds.end()
                    && locus.adjustment.direction_of_travel() == DirectionOfTravel::Add
                {
                    assert!(
                        !locus.adjustment.doubling_or_halving_flag(),
                        "D/H flag should be false. Seed {}, Locus val: {}, Adj direction: {:?}, Initial D/H would have been true",
                        i,
                        locus.value.get(),
                        &locus.adjustment.direction_of_travel()
                    );
                    return; // Test passed
                }
            }
        }
        panic!(
            "Could not find a suitable RNG seed/state for the D/H out-of-bounds (doubling) test after 500 attempts."
        );
    }

    #[test]
    fn given_new_random_locus_when_dh_flag_true_and_halving_out_of_bounds_then_dh_flag_is_false() {
        let bounds = 0.1..=10.0;

        for i in 0..5000 {
            // Try a few times to get the desired RNG state
            let mut seeded_rng = StdRng::seed_from_u64(i);
            let locus_val_candidate = seeded_rng.gen_range(bounds.clone());

            let _apply_adjustment_flag_candidate = seeded_rng.r#gen::<bool>(); // 1. Locus apply_adjustment_flag
            let dir_travel_candidate_is_subtract = !seeded_rng.r#gen::<bool>(); // 2. LocusAdjustment direction_of_travel (false for bool -> Subtract)
            let dh_flag_candidate_is_true = seeded_rng.r#gen::<bool>(); // 3. LocusAdjustment doubling_or_halving_flag

            if locus_val_candidate < (*bounds.start() * 2.0) && // Value is small enough that halving goes < bounds.start(), but still >= bounds.start()
                dh_flag_candidate_is_true && 
                dir_travel_candidate_is_subtract
            {
                let mut test_rng = StdRng::seed_from_u64(i);
                let locus = Locus::new_random(&mut test_rng, bounds.clone());

                // If initial value was positive, and halving makes it < lower_bound (0.0)
                // (Note: division by 2 of a positive will not be < 0 unless it's numerically unstable near 0)
                // The main concern is if bounds.start() is > 0, and value/2 < bounds.start()
                if locus.value.get() > 0.0
                    && (locus.value.get() / 2.0) < *bounds.start()
                    && locus.adjustment.direction_of_travel() == DirectionOfTravel::Subtract
                {
                    assert!(
                        !locus.adjustment.doubling_or_halving_flag(),
                        "D/H flag should be false for halving out of bounds. Seed {}, Locus val: {}, Adj direction: {:?}, Initial D/H would have been true",
                        i,
                        locus.value.get(),
                        &locus.adjustment.direction_of_travel()
                    );
                    return; // Test passed
                }
            }
        }
        panic!(
            "Could not find a suitable RNG seed/state for the D/H out-of-bounds (halving) test after 5000 attempts."
        );
    }

    #[test]
    fn given_new_random_locus_when_dh_flag_true_and_change_in_bounds_then_dh_flag_is_true() {
        let bounds = 0.0..=100.0;

        for i in 0..500 {
            let mut seeded_rng = StdRng::seed_from_u64(i);
            let locus_val_candidate = seeded_rng.gen_range(bounds.clone());

            let dir_travel_is_add = seeded_rng.r#gen::<bool>();
            let dh_flag_is_true = seeded_rng.r#gen::<bool>();
            seeded_rng.r#gen::<bool>(); // Consume Locus's apply_adjustment_flag bool

            let hypothetical_value = if dir_travel_is_add {
                locus_val_candidate * 2.0
            } else {
                locus_val_candidate / 2.0
            };

            if dh_flag_is_true && bounds.contains(&hypothetical_value) {
                let mut test_rng = StdRng::seed_from_u64(i);
                let locus = Locus::new_random(&mut test_rng, bounds.clone());

                // Check if the *actual* generated locus matches the conditions we were aiming for
                let actual_hypothetical_value =
                    if locus.adjustment.direction_of_travel() == DirectionOfTravel::Add {
                        locus.value.get() * 2.0
                    } else {
                        locus.value.get() / 2.0
                    };

                if locus.adjustment.doubling_or_halving_flag() && // D/H flag ended up true
                   ( (locus.adjustment.direction_of_travel() == DirectionOfTravel::Add && dir_travel_is_add) || 
                     (locus.adjustment.direction_of_travel() == DirectionOfTravel::Subtract && !dir_travel_is_add) ) && // direction matches
                   bounds.contains(&actual_hypothetical_value)
                // hypothetical value is in bounds
                {
                    assert!(
                        locus.adjustment.doubling_or_halving_flag(),
                        "D/H flag should be true. Seed {}, Locus val: {}, Adj direction: {:?}, Hypo val: {}",
                        i,
                        locus.value.get(),
                        &locus.adjustment.direction_of_travel(),
                        actual_hypothetical_value
                    );
                    return; // Test passed
                }
            }
        }
        panic!(
            "Could not find a suitable RNG seed/state for the D/H in-bounds test after 500 attempts."
        );
    }

    #[test]
    fn given_new_random_locus_when_initial_dh_flag_false_then_final_dh_flag_is_false() {
        let bounds = 0.0..=100.0;

        for i in 0..500 {
            let mut seeded_rng = StdRng::seed_from_u64(i);
            seeded_rng.gen_range(bounds.clone()); // Consume locus value gen

            seeded_rng.r#gen::<bool>(); // Consume LocusAdjustment direction gen
            let initial_dh_flag_is_false = !seeded_rng.r#gen::<bool>(); // This is the one we care about
            seeded_rng.r#gen::<bool>(); // Consume Locus apply_adjustment_flag gen

            if initial_dh_flag_is_false {
                let mut test_rng = StdRng::seed_from_u64(i);
                let locus = Locus::new_random(&mut test_rng, bounds.clone());

                // We need to ensure that the D/H flag we targeted for LocusAdjustment was indeed false
                // This requires knowing the sequence. If the *second* bool from RNG for adjustment is false.
                let mut check_rng_for_adj_dh_flag = StdRng::seed_from_u64(i);
                check_rng_for_adj_dh_flag.gen_range(bounds.clone()); // locus_val
                check_rng_for_adj_dh_flag.r#gen::<bool>(); // apply_adj_flag for Locus
                check_rng_for_adj_dh_flag.r#gen::<bool>(); // LocusAdjustment direction
                let actual_initial_dh_flag = check_rng_for_adj_dh_flag.r#gen::<bool>(); // LocusAdjustment D/H flag

                if !actual_initial_dh_flag {
                    // If the LocusAdjustment's D/H flag was generated as false
                    assert!(
                        !locus.adjustment.doubling_or_halving_flag(),
                        "D/H flag should remain false. Seed {}, Locus val: {}",
                        i,
                        locus.value.get()
                    );
                    return; // Test passed
                }
            }
        }
        panic!(
            "Could not find a suitable RNG seed for the D/H initially false test after 500 attempts."
        );
    }
}
