// src/locus/new_random_locus.rs
use crate::locus::Locus; // For the impl Locus block
use crate::locus::locus_adjustment::{DirectionOfTravel, LocusAdjustment};
use crate::parameters::parameter::Parameter;
use rand::Rng;
use std::ops::RangeInclusive;

impl Locus {
    /// Creates a new Locus with random properties within the given value_bounds.
    ///
    /// - `value`: A random f64 within `value_bounds`, stored in a Parameter whose own bounds are set to `value_bounds`.
    /// - `apply_adjustment_flag`: Randomly true or false (50/50).
    /// - `adjustment`: A LocusAdjustment generated by `LocusAdjustment::new_random`.
    pub fn new_random_locus(rng: &mut impl Rng, value_bounds: &RangeInclusive<f64>) -> Self {
        let val = rng.gen_range(value_bounds.clone());
        // Create a Parameter for LocusValue, ensuring its internal bounds match value_bounds.
        let locus_value_param =
            Parameter::with_bounds(val, *value_bounds.start(), *value_bounds.end());

        let apply_adjustment_flag = rng.r#gen::<bool>();

        // Generate a LocusAdjustment. Its internal `adjustment_value` Parameter will have default MIN/MAX bounds.
        let mut adjustment = LocusAdjustment::new_random_locus_adjustment(rng, value_bounds);

        // If adjustment's doubling_or_halving_flag is true, check if applying this operation
        // (doubling for Add, halving for Subtract) to the current locus_value_param
        // would push it outside its specific value_bounds.
        if adjustment.doubling_or_halving_flag() {
            let current_locus_val = locus_value_param.get();
            let hypothetical_locus_val = match adjustment.direction_of_travel() {
                DirectionOfTravel::Add => current_locus_val * 2.0, // Doubling
                DirectionOfTravel::Subtract => current_locus_val / 2.0, // Halving
            };

            // Check if the hypothetical new locus value is within the original value_bounds for this locus.
            if !value_bounds.contains(&hypothetical_locus_val) {
                // If the operation would push the locus value out of its bounds,
                // reconstruct the LocusAdjustment with the doubling_or_halving_flag set to false.
                adjustment = LocusAdjustment::new(
                    adjustment.adjustment_value().clone(), // Keep the original random adjustment value
                    adjustment.direction_of_travel(),
                    false, // Force flag to false
                );
            }
        }

        Self::new(
            // Use the public constructor of Locus (Self::new)
            locus_value_param,
            adjustment,
            apply_adjustment_flag,
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*; // Brings Locus::new_random into scope
    use crate::locus::locus_adjustment::{DirectionOfTravel, LocusAdjustment}; // For LocusAdjustment::new_random and DirectionOfTravel enum
    use rand::SeedableRng;
    use rand::rngs::StdRng;
    // Parameter and Locus types are available via super if needed for annotations.

    #[test]
    fn given_rng_and_bounds_when_new_random_then_locus_is_valid() {
        let mut rng = StdRng::seed_from_u64(42);
        let bounds = -10.0..=10.0;

        for _ in 0..100 {
            let locus = Locus::new_random_locus(&mut rng, &bounds); // Changed call
            assert!(
                bounds.contains(&locus.value().get()),
                "Locus value {} out of bounds {:?}",
                locus.value().get(),
                &bounds
            );
            assert_eq!(
                locus.value().bounds(),
                &bounds,
                "Locus parameter bounds incorrect"
            );
            assert!(locus.adjustment().adjustment_value().get() >= 0.0);
        }
    }

    #[test]
    fn given_new_random_locus_when_dh_flag_true_and_doubling_out_of_bounds_then_dh_flag_is_false() {
        let bounds = 50.0..=100.0;
        let mut found_case = false;
        for i in 0..10000 {
            // Increased attempts to find the specific scenario
            let mut test_rng = StdRng::seed_from_u64(i);
            let locus_candidate_val = test_rng.gen_range(bounds.clone());

            let mut adj_rng = StdRng::seed_from_u64(i);
            // Simulate the RNG state consumption that would happen before initial_adjustment is created
            adj_rng.gen_range(bounds.clone()); // For locus_value_param in new_random
            adj_rng.r#gen::<bool>(); // For apply_adjustment_flag in new_random
            // Now, the RNG state for LocusAdjustment::new_random
            let initial_adjustment =
                LocusAdjustment::new_random_locus_adjustment(&mut adj_rng, &bounds); // Changed call

            if initial_adjustment.doubling_or_halving_flag()
                && initial_adjustment.direction_of_travel() == DirectionOfTravel::Add
            {
                let hypothetical_doubled_locus_val = locus_candidate_val * 2.0;
                if !bounds.contains(&hypothetical_doubled_locus_val) {
                    let mut final_rng = StdRng::seed_from_u64(i);
                    let locus = Locus::new_random_locus(&mut final_rng, &bounds); // Changed call
                    let final_dh_flag = locus.adjustment.doubling_or_halving_flag();
                    assert!(
                        !final_dh_flag,
                        "D/H flag should be false. Seed {}, Locus val: {}, Adj direction: {:?}, Initial D/H would have been true",
                        i,
                        locus_candidate_val,
                        initial_adjustment.direction_of_travel()
                    );
                    found_case = true;
                    break;
                }
            }
        }
        assert!(
            found_case,
            "Test case for doubling out of bounds not found. Adjust seed search or logic."
        );
    }

    #[test]
    fn given_new_random_locus_when_dh_flag_true_and_halving_out_of_bounds_then_dh_flag_is_false() {
        let bounds = 1.0..=10.0;
        let mut found_case = false;
        for i in 0..10000 {
            let mut test_rng = StdRng::seed_from_u64(i);
            let locus_candidate_val = test_rng.gen_range(bounds.clone());

            let mut adj_rng = StdRng::seed_from_u64(i);
            adj_rng.gen_range(bounds.clone());
            adj_rng.r#gen::<bool>();
            let initial_adjustment =
                LocusAdjustment::new_random_locus_adjustment(&mut adj_rng, &bounds); // Changed call

            if initial_adjustment.doubling_or_halving_flag()
                && initial_adjustment.direction_of_travel() == DirectionOfTravel::Subtract
            {
                let hypothetical_halved_locus_val = locus_candidate_val / 2.0;
                if !bounds.contains(&hypothetical_halved_locus_val) {
                    let mut final_rng = StdRng::seed_from_u64(i);
                    let locus = Locus::new_random_locus(&mut final_rng, &bounds); // Changed call
                    let final_dh_flag = locus.adjustment.doubling_or_halving_flag();
                    assert!(
                        !final_dh_flag,
                        "D/H flag should be false for halving out of bounds. Seed {}, Locus val: {}, Adj direction: {:?}, Initial D/H would have been true",
                        i,
                        locus_candidate_val,
                        initial_adjustment.direction_of_travel()
                    );
                    found_case = true;
                    break;
                }
            }
        }
        assert!(
            found_case,
            "Test case for halving out of bounds not found. Adjust seed search or logic."
        );
    }

    #[test]
    fn given_new_random_locus_when_dh_flag_true_and_change_in_bounds_then_dh_flag_is_true() {
        let bounds = 0.0..=100.0;
        let mut found_case = false;
        for i in 0..10000 {
            let mut test_rng = StdRng::seed_from_u64(i);
            let locus_candidate_val = test_rng.gen_range(bounds.clone());

            let mut adj_rng = StdRng::seed_from_u64(i);
            adj_rng.gen_range(bounds.clone());
            adj_rng.r#gen::<bool>();
            let initial_adjustment =
                LocusAdjustment::new_random_locus_adjustment(&mut adj_rng, &bounds); // Changed call

            if initial_adjustment.doubling_or_halving_flag() {
                let hypothetical_val = match initial_adjustment.direction_of_travel() {
                    DirectionOfTravel::Add => locus_candidate_val * 2.0,
                    DirectionOfTravel::Subtract => locus_candidate_val / 2.0,
                };
                if bounds.contains(&hypothetical_val) {
                    let mut final_rng = StdRng::seed_from_u64(i);
                    let locus = Locus::new_random_locus(&mut final_rng, &bounds); // Changed call
                    let final_dh_flag = locus.adjustment.doubling_or_halving_flag();
                    assert!(
                        final_dh_flag,
                        "D/H flag should be true. Seed {}, Locus val: {}, Adj direction: {:?}, Hypothetical: {}",
                        i,
                        locus_candidate_val,
                        initial_adjustment.direction_of_travel(),
                        hypothetical_val
                    );
                    found_case = true;
                    break;
                }
            }
        }
        assert!(
            found_case,
            "Test case for D/H flag true and in bounds not found."
        );
    }

    #[test]
    fn given_new_random_locus_when_initial_dh_flag_false_then_final_dh_flag_is_false() {
        let bounds = 0.0..=100.0;
        let mut found_case = false;
        for i in 0..10000 {
            let mut adj_rng_setup = StdRng::seed_from_u64(i);
            adj_rng_setup.gen_range(bounds.clone()); // Consumed by Locus::new_random for locus_value_param
            adj_rng_setup.r#gen::<bool>(); // Consumed by Locus::new_random for apply_adjustment_flag

            // Now, this RNG state is what LocusAdjustment::new_random will see
            let mut adj_rng_for_check = adj_rng_setup.clone();
            adj_rng_for_check.r#gen::<bool>(); // direction_of_travel for LocusAdjustment
            let initial_dh_flag_for_adjustment = adj_rng_for_check.r#gen::<bool>(); // doubling_or_halving_flag for LocusAdjustment

            if !initial_dh_flag_for_adjustment {
                let mut final_rng = StdRng::seed_from_u64(i);
                let locus = Locus::new_random_locus(&mut final_rng, &bounds); // Changed call
                let final_dh_flag = locus.adjustment.doubling_or_halving_flag();
                assert!(!final_dh_flag, "D/H flag should remain false. Seed {}", i);
                found_case = true;
                break;
            }
        }
        assert!(
            found_case,
            "Test case for initial D/H flag false not found."
        );
    }
}
